import * as _angular_material_snack_bar from '@angular/material/snack-bar';
import { MatSnackBarConfig } from '@angular/material/snack-bar';
import * as _angular_core from '@angular/core';
import { ElementRef, AfterContentInit, OnChanges, OnInit, OnDestroy, EventEmitter, QueryList, ViewContainerRef, SimpleChanges, Injector, InjectionToken, PipeTransform } from '@angular/core';
import * as _angular_material_paginator from '@angular/material/paginator';
import { PageEvent } from '@angular/material/paginator';
import { MatTableDataSource, MatHeaderRowDef, MatRowDef, MatFooterRowDef, MatColumnDef, MatNoDataRow, MatTable } from '@angular/material/table';
import { SelectionModel } from '@angular/cdk/collections';
import { MatChipInputEvent, MatChipEditedEvent } from '@angular/material/chips';
import { LiveAnnouncer } from '@angular/cdk/a11y';
import { ThemePalette } from '@angular/material/core';
import * as rxjs from 'rxjs';
import { Observable } from 'rxjs';
import { HttpContext, HttpRequest, HttpInterceptorFn } from '@angular/common/http';
import { ScrollStrategy, Overlay } from '@angular/cdk/overlay';
import { MatDialogRef } from '@angular/material/dialog';
import { ComponentType } from '@angular/cdk/portal';

type SnackbarType = 'success' | 'warning' | 'info' | 'error';
interface SnackbarProps {
    readonly type: SnackbarType;
    readonly message: string;
    readonly title?: string;
    readonly action?: string;
    readonly config?: Partial<_angular_material_snack_bar.MatSnackBarConfig>;
}
interface NotificationCallProps {
    readonly message: string;
    readonly title?: string;
    readonly config?: Partial<_angular_material_snack_bar.MatSnackBarConfig>;
}
interface NotificationDemo {
    type: SnackbarType;
    message: string;
    title?: string;
    duration?: number;
}

declare class FieldDefinition {
    value?: any;
    valueLabel?: any;
    defaultValue?: any;
    defaultValueLabel?: any;
    key: string;
    label: string;
    dateRangeConfig?: DateRangeConfig;
    isDefaultSearchField?: boolean;
    required?: boolean;
    disabled?: boolean;
    order?: number;
    icon?: string;
    controlType?: ControlType;
    type?: FieldType;
    editor?: 'numeric' | 'boolean' | '';
    options?: any[];
    valueOptions?: string[];
    valuePrimitive?: boolean;
    textField?: string;
    valueField?: string;
    errorMessage?: string;
    width?: string;
    valueChangeCallback?: Function;
    columnType?: ColumnType;
    body?: any;
    constructor(options?: {
        value?: any;
        valueLabel?: any;
        defaultValue?: any;
        defaultValueLabel?: any;
        key?: string;
        label?: string;
        dateRangeConfig?: DateRangeConfig;
        isDefaultSearchField?: boolean;
        required?: boolean;
        disabled?: boolean;
        order?: number;
        icon?: string;
        controlType?: ControlType;
        type?: FieldType;
        editor?: 'numeric' | 'boolean';
        options?: any[];
        valueOptions?: string[];
        errorMessage?: string;
        width?: string;
        valueChangeCallback?: Function;
    });
}
interface DateRangeConfig {
    startDate: FieldDefinition;
    endDate: FieldDefinition;
}
declare type ControlType = 'textbox' | 'ktextbox' | 'combobox' | 'textboxNum' | 'dropdown' | 'dropdownlist' | 'multiselect' | 'autocomplete' | 'checkbox' | 'radiobutton' | 'inquiryInDialog' | 'timepicker' | 'datepicker' | 'daterange' | 'textarea' | 'slideToggle' | 'slider' | 'switch' | 'buttonToggleGroup';
declare type FieldType = 'number' | 'string' | 'boolean' | 'date' | 'month' | 'email' | 'password' | 'tel' | 'hidden' | 'image' | 'url' | 'week' | 'search' | 'reset' | 'template' | 'custom';
declare type ColumnType = 'text' | 'component' | 'html' | 'template';

declare class ColumnDefinition extends FieldDefinition {
    index?: number;
    format?: any;
    hasFooter?: boolean;
    hideInOverlay?: boolean;
    optionsAttribut?: string;
    templateOutlet?: any;
}

interface OptionSearchConfig<T> {
    displayedColumns?: string[];
    displayColumnDefs?: ColumnDefinition[];
    close?: boolean;
}

declare class TableCellIndex {
    row: number;
    column: number;
    constructor(row: number, column: number);
}

declare class Pagination {
    pageIndex: number;
    pageSize: number;
    maxSize: number;
    totalRecords: number;
    pageSizeOptions: number[];
    /**
     * @param pageIndex Current page index (0-based for MatPagination compatibility)
     * @param pageSize Number of records per page
     * @param maxSize Maximum number of pages displayed in the pagination control
     * @param totalRecords Total number of records
     * @param pageSizeOptions Available page size options
     */
    constructor(pageIndex?: number, // MatPagination starts at 0
    pageSize?: number, maxSize?: number, totalRecords?: number, pageSizeOptions?: number[]);
    /**
     * Calculates the total number of pages.
     */
    getTotalPages(): number;
    /**
     * Updates the page size and resets the page index to the first page.
     * @param newPageSize The new page size
     */
    updatePageSize(newPageSize: number): void;
    /**
     * Updates pagination data based on paginator event.
     * @param event MatPaginator event
     */
    updateFromPaginatorEvent(event: any): void;
}

declare const SNACKBAR_MESSAGES: {
    readonly SUCCESS: {
        readonly SAVE: "Data saved successfully";
        readonly DELETE: "Item deleted successfully";
        readonly UPDATE: "Data updated successfully";
        readonly UPLOAD: "File uploaded successfully";
    };
    readonly ERROR: {
        readonly SAVE: "Failed to save data";
        readonly DELETE: "Failed to delete item";
        readonly UPDATE: "Failed to update data";
        readonly UPLOAD: "Failed to upload file";
        readonly NETWORK: "Network error occurred";
        readonly UNKNOWN: "An unexpected error occurred";
    };
    readonly WARNING: {
        readonly UNSAVED_CHANGES: "You have unsaved changes";
        readonly SESSION_EXPIRING: "Your session is about to expire";
        readonly STORAGE_FULL: "Storage is running low";
    };
    readonly INFO: {
        readonly LOADING: "Loading data...";
        readonly PROCESSING: "Processing request...";
        readonly MAINTENANCE: "System maintenance scheduled";
    };
};
declare const SNACKBAR_DURATIONS: {
    readonly SHORT: 3000;
    readonly MEDIUM: 5000;
    readonly LONG: 8000;
    readonly PERSISTENT: 0;
};
declare const SNACKBAR_ICONS: Record<SnackbarType, string>;

interface MatCustomDialogOptions {
    showButtonClose?: boolean | true | false;
}
declare class MatCustomDialogComponent {
    showHeader: _angular_core.InputSignal<boolean>;
    loading: _angular_core.InputSignal<boolean>;
    align: _angular_core.InputSignal<"start" | "center" | "end">;
    title: _angular_core.InputSignal<string>;
    icon: _angular_core.InputSignal<string>;
    options: _angular_core.InputSignal<MatCustomDialogOptions>;
    close: _angular_core.OutputEmitterRef<void>;
    header: ElementRef;
    private static lastZIndex;
    toTop(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<MatCustomDialogComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<MatCustomDialogComponent, "acp-mat-custom-dialog", never, { "showHeader": { "alias": "showHeader"; "required": false; "isSignal": true; }; "loading": { "alias": "loading"; "required": false; "isSignal": true; }; "align": { "alias": "align"; "required": false; "isSignal": true; }; "title": { "alias": "title"; "required": false; "isSignal": true; }; "icon": { "alias": "icon"; "required": false; "isSignal": true; }; "options": { "alias": "options"; "required": false; "isSignal": true; }; }, { "close": "close"; }, never, ["*", "*"], true, never>;
}

declare class CustomTabulatorComponent {
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<CustomTabulatorComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<CustomTabulatorComponent, "lib-custom-tabulator", never, {}, {}, never, never, true, never>;
}

declare class MatDynamicTableComponent<T> implements AfterContentInit, OnChanges, OnInit, OnDestroy {
    private viewContainerRef;
    private injector;
    private embeddedViews;
    showExpand: boolean;
    showFooter: boolean;
    locale: string;
    highlightRowIndex: number;
    visibleColumns: string[];
    columnDefinitions: ColumnDefinition[];
    columnsToDisplayWithExpand: string[];
    showSelectBox: boolean;
    tableData: T[];
    rowSelected: EventEmitter<T[]>;
    copyRow: EventEmitter<T>;
    showExpanded: _angular_core.OutputEmitterRef<T>;
    hideExpanded: _angular_core.OutputEmitterRef<T>;
    dataSource: MatTableDataSource<T, _angular_material_paginator.MatPaginator>;
    selection: SelectionModel<T>;
    headerRowDefs: QueryList<MatHeaderRowDef>;
    rowDefs: QueryList<MatRowDef<T>>;
    footerRowDefs: QueryList<MatFooterRowDef>;
    columnDefs: QueryList<MatColumnDef>;
    noDataRow: MatNoDataRow;
    table: MatTable<T>;
    rows: QueryList<ViewContainerRef>;
    templateOp: any | null;
    expandedDetail: any | null;
    expandedElement: T | null;
    enablePagination: _angular_core.InputSignal<boolean>;
    pageEvent: _angular_core.OutputEmitterRef<PageEvent>;
    paginationConfig: _angular_core.InputSignal<Pagination | undefined>;
    handlePageEvent(e: PageEvent): void;
    isLoadingData: _angular_core.InputSignal<boolean>;
    ngAfterContentInit(): void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    createInjector: (element: any) => Injector;
    createEmbeddedView(column: any, element: any): void;
    moveNextRow(cell: TableCellIndex): void;
    selectRow(row: T): void;
    /** Whether the number of selected elements matches the total number of rows. */
    isAllSelected(): boolean;
    /** Selects all rows if they are not all selected; otherwise clear selection. */
    masterToggle(): void;
    /** The label for the checkbox on the passed row */
    checkboxLabel(row?: T): string;
    showElement(index: number, height: number): void;
    onHighlightedRowChange(event: KeyboardEvent): void;
    getRowColor(element: any): string;
    onExpand($event: any, element: T): void;
    ngOnDestroy(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<MatDynamicTableComponent<any>, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<MatDynamicTableComponent<any>, "acp-mat-dynamic-table", never, { "showExpand": { "alias": "showExpand"; "required": false; }; "showFooter": { "alias": "showFooter"; "required": false; }; "locale": { "alias": "locale"; "required": false; }; "highlightRowIndex": { "alias": "highlightRowIndex"; "required": false; }; "visibleColumns": { "alias": "visibleColumns"; "required": false; }; "columnDefinitions": { "alias": "columnDefinitions"; "required": false; }; "showSelectBox": { "alias": "showSelectBox"; "required": false; }; "tableData": { "alias": "tableData"; "required": false; }; "templateOp": { "alias": "templateOp"; "required": false; }; "expandedDetail": { "alias": "expandedDetail"; "required": false; }; "enablePagination": { "alias": "enablePagination"; "required": false; "isSignal": true; }; "paginationConfig": { "alias": "paginationConfig"; "required": false; "isSignal": true; }; "isLoadingData": { "alias": "isLoadingData"; "required": false; "isSignal": true; }; }, { "rowSelected": "rowSelected"; "copyRow": "copyRow"; "showExpanded": "showExpanded"; "hideExpanded": "hideExpanded"; "pageEvent": "pageEvent"; }, ["noDataRow", "headerRowDefs", "rowDefs", "footerRowDefs", "columnDefs", "rows"], never, true, never>;
}

declare class MatInputChipComponent {
    chips: _angular_core.InputSignal<string[]>;
    labelText: _angular_core.InputSignal<string>;
    placelholder: _angular_core.InputSignal<string>;
    addOnBlur: boolean;
    readonly separatorKeysCodes: readonly [13, 188];
    announcer: LiveAnnouncer;
    add(event: MatChipInputEvent): void;
    remove(value: string): void;
    edit(inputRaw: string, event: MatChipEditedEvent): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<MatInputChipComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<MatInputChipComponent, "lib-mat-input-chip", never, { "chips": { "alias": "chips"; "required": true; "isSignal": true; }; "labelText": { "alias": "labelText"; "required": true; "isSignal": true; }; "placelholder": { "alias": "placelholder"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

type ButtonVariant = 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
type ButtonType = 'button' | 'submit' | 'reset';
type MaterialButtonStyle = 'basic' | 'raised' | 'flat' | 'stroked' | 'icon' | 'fab' | 'mini-fab';
declare class MatThemeButtonComponent {
    variant: _angular_core.InputSignal<ButtonVariant>;
    text: _angular_core.InputSignal<string>;
    icon: _angular_core.InputSignal<string>;
    outlined: _angular_core.InputSignal<boolean>;
    disabled: _angular_core.InputSignal<boolean>;
    useThemeColor: _angular_core.InputSignal<boolean>;
    type: _angular_core.InputSignal<ButtonType>;
    matStyle: _angular_core.InputSignal<MaterialButtonStyle>;
    title: _angular_core.InputSignal<string>;
    ariaLabel: _angular_core.InputSignal<string>;
    name: _angular_core.InputSignal<string>;
    id: _angular_core.InputSignal<string>;
    form: _angular_core.InputSignal<string>;
    tabIndex: _angular_core.InputSignal<number>;
    testId: _angular_core.InputSignal<string>;
    handleClick: _angular_core.OutputEmitterRef<unknown>;
    getButtonClasses(): Record<string, boolean>;
    getThemeColor(): ThemePalette | null;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<MatThemeButtonComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<MatThemeButtonComponent, "acp-mat-theme-button", never, { "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "text": { "alias": "text"; "required": false; "isSignal": true; }; "icon": { "alias": "icon"; "required": false; "isSignal": true; }; "outlined": { "alias": "outlined"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "useThemeColor": { "alias": "useThemeColor"; "required": false; "isSignal": true; }; "type": { "alias": "type"; "required": false; "isSignal": true; }; "matStyle": { "alias": "matStyle"; "required": false; "isSignal": true; }; "title": { "alias": "title"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; "name": { "alias": "name"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "form": { "alias": "form"; "required": false; "isSignal": true; }; "tabIndex": { "alias": "tabIndex"; "required": false; "isSignal": true; }; "testId": { "alias": "testId"; "required": false; "isSignal": true; }; }, { "handleClick": "handleClick"; }, never, ["*", "svgIcon", "*", "*", "*", "*", "*", "*", "svgIcon", "*"], true, never>;
}

declare class SpinnerComponent {
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SpinnerComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SpinnerComponent, "acp-spinner", never, {}, {}, never, never, true, never>;
}

declare class SnackbarNotificationComponent {
    private readonly snackbarService;
    protected readonly customNotification: _angular_core.WritableSignal<NotificationDemo>;
    protected readonly quickMessages: {
        readonly success: "Data saved successfully";
        readonly info: "Loading data...";
        readonly warning: "You have unsaved changes";
        readonly error: "Network error occurred";
    };
    protected showQuickNotification(type: SnackbarType): void;
    protected showCustomNotification(): void;
    protected isFormValid(): boolean;
    protected resetForm(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SnackbarNotificationComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<SnackbarNotificationComponent, "acp-snackbar-notification", never, {}, {}, never, never, true, never>;
}

type DialogSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' | 'full';
interface DialogPosition {
    top?: string;
    bottom?: string;
    left?: string;
    right?: string;
}
interface DialogConfig<T = any> {
    size?: DialogSize;
    width?: string;
    height?: string;
    minWidth?: string;
    minHeight?: string;
    maxWidth?: string;
    maxHeight?: string;
    position?: DialogPosition;
    panelClass?: string | string[];
    backdropClass?: string | string[];
    hasBackdrop?: boolean;
    backdropClickClosable?: boolean;
    escapeKeyClosable?: boolean;
    autoFocus?: boolean | string;
    restoreFocus?: boolean;
    enterAnimationDuration?: number | string;
    exitAnimationDuration?: number | string;
    data?: T;
    scrollStrategy?: ScrollStrategy;
    ariaLabel?: string;
    ariaLabelledBy?: string;
    ariaDescribedBy?: string;
    role?: 'dialog' | 'alertdialog';
    isMobileFullScreen?: boolean;
}

declare class DialogService {
    private readonly dialog;
    private readonly overlay;
    private readonly breakpointObserver;
    private readonly isMobile$;
    /**
     * Opens a dialog with the specified component and configuration
     */
    open<T, D = any, R = any>(component: ComponentType<T>, config?: DialogConfig<D>): MatDialogRef<T, R>;
    /**
     * Opens a dialog and returns only the result observable
     */
    openAndGetResult<T, D = any, R = any>(component: ComponentType<T>, config?: DialogConfig<D>): Observable<R | undefined>;
    /**
     * Opens a confirmation dialog (helper method)
     */
    openConfirmation<T>(component: ComponentType<T>, data?: any, config?: Partial<DialogConfig>): Observable<boolean>;
    /**
     * Closes all open dialogs
     */
    closeAll(): void;
    /**
     * Gets all open dialogs
     */
    getOpenDialogs(): MatDialogRef<any>[];
    private buildDialogConfig;
    private applyFullScreenConfig;
    private applyStandardConfig;
    private applyCommonConfig;
    private getDialogWidth;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<DialogService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<DialogService>;
}

declare class OverlayService {
    private overlay;
    private overlayRef;
    constructor(overlay: Overlay);
    showSpinner(): void;
    hideSpinner(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<OverlayService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<OverlayService>;
}

interface SnackbarConfig extends MatSnackBarConfig {
    readonly defaultAction?: string;
    readonly iconEnabled?: boolean;
    readonly titleEnabled?: boolean;
}
declare const DEFAULT_SNACKBAR_CONFIG: SnackbarConfig;
declare const SNACKBAR_CONFIG: InjectionToken<SnackbarConfig>;

declare class SnackbarService {
    private readonly snackBar;
    private readonly config;
    /**
     * Display a snackbar with specific type and configuration
     */
    show(props: SnackbarProps): void;
    /**
     * Quick success notification
     */
    success(props: NotificationCallProps): void;
    /**
     * Quick error notification with longer duration
     */
    error(props: NotificationCallProps): void;
    /**
     * Quick warning notification
     */
    warning(props: NotificationCallProps): void;
    /**
     * Quick info notification
     */
    info(props: NotificationCallProps): void;
    private buildPanelClasses;
    private buildMessage;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<SnackbarService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<SnackbarService>;
}

declare class ThemeService {
    private readonly _darkMode;
    isDarkMode$: rxjs.Observable<boolean>;
    loadMode(): void;
    toggleDarkMode(): void;
    private applyTheme;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<ThemeService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<ThemeService>;
}

declare class ThemeToggleComponent {
    private themeService;
    darkMode$: Observable<boolean>;
    constructor(themeService: ThemeService);
    toggleDarkMode(): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<ThemeToggleComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<ThemeToggleComponent, "acp-theme-toggle", never, {}, {}, never, never, true, never>;
}

declare const DYNAMIC_INPUT: InjectionToken<unknown>;

/**
 * Helper function to disable spinner for specific requests
 * @returns HttpContext with spinner disabled
 */
declare function withoutSpinner(): HttpContext;
/**
 * Service to track active HTTP requests
 */
declare class ActiveRequestsTracker {
    private requests;
    get count(): number;
    add(request: HttpRequest<any>): void;
    remove(request: HttpRequest<any>): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<ActiveRequestsTracker, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<ActiveRequestsTracker>;
}
/**
 * Interceptor that shows/hides a loading spinner based on active HTTP requests
 */
declare const spinnerInterceptor: HttpInterceptorFn;

declare class GetTotalPipe implements PipeTransform {
    transform(colName: string, dataSource: any[]): any;
    /**
     * Calculate and return the total (sum) of all the column --> the column must be number
     */
    getTotal(colName: string, dataSource: any[]): number;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<GetTotalPipe, never>;
    static ɵpipe: _angular_core.ɵɵPipeDeclaration<GetTotalPipe, "getTotal", true>;
}

export { ActiveRequestsTracker, ColumnDefinition, CustomTabulatorComponent, DEFAULT_SNACKBAR_CONFIG, DYNAMIC_INPUT, DialogService, FieldDefinition, GetTotalPipe, MatCustomDialogComponent, MatDynamicTableComponent, MatInputChipComponent, MatThemeButtonComponent, OverlayService, Pagination, SNACKBAR_CONFIG, SNACKBAR_DURATIONS, SNACKBAR_ICONS, SNACKBAR_MESSAGES, SnackbarNotificationComponent, SnackbarService, SpinnerComponent, TableCellIndex, ThemeService, ThemeToggleComponent, spinnerInterceptor, withoutSpinner };
export type { ButtonType, ButtonVariant, ColumnType, ControlType, DateRangeConfig, DialogConfig, DialogPosition, DialogSize, FieldType, MatCustomDialogOptions, MaterialButtonStyle, NotificationCallProps, NotificationDemo, OptionSearchConfig, SnackbarConfig, SnackbarProps, SnackbarType };
